#version 450

#extension GL_EXT_mesh_shader : enable
#extension GL_EXT_buffer_reference : require
#extension GL_GOOGLE_include_directive : enable

#include "common.h"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(triangles, max_vertices = 3, max_primitives = 1) out;
layout(location = 1) out vec2 uv[];
layout(location = 2) flat out uint materialIndex[];
layout(location = 3) out vec3 position[];
layout(location = 4) out vec3 normal[];

layout(buffer_reference, std430) readonly buffer VertexBuffer{ 
	Vertex vertices[];
};
layout(buffer_reference, std430) readonly buffer IndexBuffer{ 
	uvec4 indices[];
};
layout(buffer_reference, std430) readonly buffer MaterialBuffer{ 
	Material materials[];
};
layout(buffer_reference, std430) readonly buffer PointLightBuffer{
	PointLight pointLights[];
};
layout(buffer_reference, std430) readonly buffer DirLightBuffer{
	DirLight dirLights[];
};
layout(buffer_reference, std430) readonly buffer SpotLightBuffer{
	SpotLight spotLights[];
};
layout(push_constant, std430) uniform constant
{
	mat4 projView;
	mat4 worldTransform;

	// Pointlight, spotlight, dirlight, meshlight count.
	vec4 PLSLDLML_lightsCount;

	VertexBuffer vertexBuffer;
	IndexBuffer indexBuffer;
	MaterialBuffer materialBuffer;
	PointLightBuffer pointLightBuffer;
};

void main()
{
	uint vertexCount = 3;
	uint triangleCount = 1;
	SetMeshOutputsEXT(vertexCount, triangleCount);

	uvec4 indexTuple = indexBuffer.indices[gl_WorkGroupID.x];

	Vertex a = vertexBuffer.vertices[ indexTuple.x ];
	Vertex b = vertexBuffer.vertices[ indexTuple.y ];
	Vertex c = vertexBuffer.vertices[ indexTuple.z ];

	gl_MeshVerticesEXT[0].gl_Position = projView * vec4(a.Position, 1.0);
	gl_MeshVerticesEXT[1].gl_Position = projView * vec4(b.Position, 1.0);
	gl_MeshVerticesEXT[2].gl_Position = projView * vec4(c.Position, 1.0);
	position[0] = (worldTransform * vec4(a.Position, 1)).xyz;
	position[1] = (worldTransform * vec4(b.Position, 1)).xyz;
	position[2] = (worldTransform * vec4(c.Position, 1)).xyz;

	gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
	uv[0] = vec2(a.U, a.V);
	uv[1] = vec2(b.U, b.V);
	uv[2] = vec2(c.U, c.V);
	materialIndex[0] = indexTuple.w;
	materialIndex[1] = indexTuple.w;
	materialIndex[2] = indexTuple.w;

	mat3 normalTransform = mat3(transpose(inverse(worldTransform)));
	normal[0] = normalTransform * a.Normal;
	normal[1] = normalTransform * b.Normal;
	normal[2] = normalTransform * c.Normal;
}